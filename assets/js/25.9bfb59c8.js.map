{"version":3,"sources":["webpack:///source/_posts/how-does-array-slice-call-arguments-work.md","webpack:///./source/_posts/how-does-array-slice-call-arguments-work.md?c9c5","webpack:///./source/_posts/how-does-array-slice-call-arguments-work.md","webpack:///./source/_posts/how-does-array-slice-call-arguments-work.md?7e42"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA,G;;;;;;;;;;;;;;ACfA;AAAA,0BAA0B,aAAa,0BAA0B,wBAAwB;AACzF,oCAAoC,aAAa,0BAA0B,wBAAwB,iBAAiB,sBAAsB,26BAA26B,sCAAsC,YAAY,gBAAgB,uBAAuB,wCAAwC,OAAO,6BAA6B,+CAA+C,OAAO,6BAA6B,2CAA2C,OAAO,6BAA6B,2BAA2B,OAAO,0BAA0B,8BAA8B,OAAO,6BAA6B,+CAA+C,OAAO,6BAA6B,wCAAwC,OAAO,yBAAyB,iDAAiD,OAAO,6BAA6B,2BAA2B,OAAO,wBAAwB,iCAAiC,OAAO,6BAA6B,uCAAuC,OAAO,wBAAwB,iCAAiC,OAAO,6BAA6B,qNAAqN,sCAAsC,YAAY,gBAAgB,uBAAuB,wBAAwB,OAAO,6BAA6B,2BAA2B,OAAO,6BAA6B,2BAA2B,OAAO,6BAA6B,2CAA2C,OAAO,6BAA6B,2BAA2B,OAAO,0BAA0B,8BAA8B,OAAO,6BAA6B,+CAA+C,OAAO,6BAA6B,qCAAqC;;;;;;;;;;;;;;;;;;ACD/vF;AAClC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gF;;;;;;;;;;;;;;wCClB+U,6WAAoB,C","file":"assets/js/25.9bfb59c8.js","sourcesContent":["<template>\n<div class=\"content\"><p>首先 <code>.slice</code> 这个方法在不接受任何参数的时候会返回 <code>this</code> 本身，这是一个 <code>Array.prototype</code> 下的方法，因此 <code>this</code> 就是指向调用 <code>.slice</code> 方法的数组本身。</p>\n<p><code>arguments</code> 是什么? <code>arguments</code> 是属于函数内部的变量，其值是函数参数列表，一个类数组对象:</p>\n<p>https://codepan.net/gist/edb0a855276de09d24ac0e5621957974</p>\n<p>类数组对象可以像真正的数组对象一样操作，除了没有 length 属性，但这足以让 <code>.slice</code> 方法识别了。</p>\n<p>你不可能用 <code>arguments.slice()</code> 这样的形式调用，因为 <code>arguments</code> 本身还是一个非数组对象，只是像数组。这个时候你想到了 <code>.call</code> 方法，这个方法让你可以自定义调用函数的内部 this 指向哪里，之前说过，默认是指向调用这个函数的对象。</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code>Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// output:</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'world'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>这样你就得到了一个真正的参数数组了，而 <code>.slice</code> 除了通过 <code>Array.prototype</code> 访问当然还可以通过对象直接量访问:</p>\n<!--beforebegin--><div class=\"language-js extra-class\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n</template>\n<script>export default { props: ['target'] }</script>","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('p',[_vm._v(\"首先 \"),_c('code',[_vm._v(\".slice\")]),_vm._v(\" 这个方法在不接受任何参数的时候会返回 \"),_c('code',[_vm._v(\"this\")]),_vm._v(\" 本身，这是一个 \"),_c('code',[_vm._v(\"Array.prototype\")]),_vm._v(\" 下的方法，因此 \"),_c('code',[_vm._v(\"this\")]),_vm._v(\" 就是指向调用 \"),_c('code',[_vm._v(\".slice\")]),_vm._v(\" 方法的数组本身。\")]),_vm._v(\" \"),_c('p',[_c('code',[_vm._v(\"arguments\")]),_vm._v(\" 是什么? \"),_c('code',[_vm._v(\"arguments\")]),_vm._v(\" 是属于函数内部的变量，其值是函数参数列表，一个类数组对象:\")]),_vm._v(\" \"),_c('p',[_vm._v(\"https://codepan.net/gist/edb0a855276de09d24ac0e5621957974\")]),_vm._v(\" \"),_c('p',[_vm._v(\"类数组对象可以像真正的数组对象一样操作，除了没有 length 属性，但这足以让 \"),_c('code',[_vm._v(\".slice\")]),_vm._v(\" 方法识别了。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"你不可能用 \"),_c('code',[_vm._v(\"arguments.slice()\")]),_vm._v(\" 这样的形式调用，因为 \"),_c('code',[_vm._v(\"arguments\")]),_vm._v(\" 本身还是一个非数组对象，只是像数组。这个时候你想到了 \"),_c('code',[_vm._v(\".call\")]),_vm._v(\" 方法，这个方法让你可以自定义调用函数的内部 this 指向哪里，之前说过，默认是指向调用这个函数的对象。\")]),_vm._v(\" \"),_c('div',{staticClass:\"language-js extra-class\"},[_c('pre',{pre:true,attrs:{\"class\":\"language-js\"}},[_c('code',[_vm._v(\"Array\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_vm._v(\"prototype\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_vm._v(\"slice\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{attrs:{\"class\":\"token function\"}},[_vm._v(\"call\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"(\")]),_vm._v(\"arguments\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\")\")]),_vm._v(\"\\n\"),_c('span',{attrs:{\"class\":\"token comment\"}},[_vm._v(\"// output:\")]),_vm._v(\"\\n\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"[\")]),_c('span',{attrs:{\"class\":\"token string\"}},[_vm._v(\"'hello'\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\",\")]),_vm._v(\" \"),_c('span',{attrs:{\"class\":\"token string\"}},[_vm._v(\"'world'\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"]\")]),_vm._v(\"\\n\")])])]),_c('p',[_vm._v(\"这样你就得到了一个真正的参数数组了，而 \"),_c('code',[_vm._v(\".slice\")]),_vm._v(\" 除了通过 \"),_c('code',[_vm._v(\"Array.prototype\")]),_vm._v(\" 访问当然还可以通过对象直接量访问:\")]),_vm._v(\" \"),_c('div',{staticClass:\"language-js extra-class\"},[_c('pre',{pre:true,attrs:{\"class\":\"language-js\"}},[_c('code',[_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"[\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"]\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_vm._v(\"slice\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{attrs:{\"class\":\"token function\"}},[_vm._v(\"call\")]),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"(\")]),_vm._v(\"arguments\"),_c('span',{attrs:{\"class\":\"token punctuation\"}},[_vm._v(\")\")]),_vm._v(\"\\n\")])])])])}]\n\nexport { render, staticRenderFns }","import { render, staticRenderFns } from \"./how-does-array-slice-call-arguments-work.md?vue&type=template&id=77d9dab3&\"\nimport script from \"./how-does-array-slice-call-arguments-work.md?vue&type=script&lang=js&\"\nexport * from \"./how-does-array-slice-call-arguments-work.md?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--3-0!../../../../node_modules/babel-loader/lib/index.js??ref--3-1!../../../../node_modules/vue-loader/lib/index.js??ref--1-1!../../../@vuepress/core/lib/webpack/markdownLoader.js??ref--1-2!./how-does-array-slice-call-arguments-work.md?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--3-0!../../../../node_modules/babel-loader/lib/index.js??ref--3-1!../../../../node_modules/vue-loader/lib/index.js??ref--1-1!../../../@vuepress/core/lib/webpack/markdownLoader.js??ref--1-2!./how-does-array-slice-call-arguments-work.md?vue&type=script&lang=js&\""],"sourceRoot":""}